---
title: "Reverse Engineering McDonalds Loyalty App's QR Code"
date: 2025-11-08T01:00:00+03:00
categories:
- "Engineering"
comments: false
toc: false
meta:
- categories
- date
draft: false
---

## Background

Our current project involves loyalty and one of the apps we look at a lot is the McDonalds loyalty app.

In the McDonalds loyalty app, there is a QR Code which typically consists of the letter M followed by 6-digits.

A customer can scan this QR Code at a McDonalds kiosk to earn points for thier order.

As the customer accumulates points, they can redeem offers in exchange for those points. In this case, a customer selects the offer, a QR code is generated, the customer scans this QR code at the kiosk and the offer is added to their cart on the kiosk. 

On the McDonalds loyalty app, the customer has 15 minutes to scan the QR code before it becomes invalid. 

What piqued my curiosity was the 6 digit number: given the huge volume of orders that McDonalds handles, plus given the popularity of the brand and consequently its loyalty app, is 6-digits enough? 

I wanted to figure out how it works on my own before decompiling the McDonalds Loyalty App. What follows is my theory.

----

## What is the QR Code used for? 

My first step was to try to understand what is the QR Code being used for in the customer journey. 

This seems pretty straight forward: The QR Code links a session on the mobile app with a session on the kiosk.

So in the case of earning points, each QR Code corresponds to a user and, once the transaction is completed, the points for the transaction are awarded to the customer.

Similarly, in the case of redeeming offers, the QR code corresponds to an offer (or perhaps a cart of offers). When the QR code is scanned, the kiosk fetches the offers corresponding to the QR Code and adds the line items to their order.

So my first draft of the database schema looks something like this:

![Schema v1](/McDonalds/Schema-v1.jpeg)

** _Yes, the offer part of this schema is oversimplified._

The RPC call sent from the kiosk might look something like this: 

**Request**

```
GET /loyalty_session?qr_code=M204941
```

**Response**
```json
{
    "sessionId": "s_101",
    "userId": "u_002",
    "offers":[{
        "sku": "free_ice_cream",
        "quantity": 1
    }]
}
```

## Recycling

The QR codes are 6 digits. Assumming 'M000000' is a valid QR code, there are 1,000,000 possible values for the code. 

A QR code is generated when the customer wants to earn points and for each offer they wish to redeem. At the moment, a maximum of two offers can be redeemed for a single kiosk transaction.

The QR code can be used both at restaurants as well as on delivery orders. 

Therefore, I doubt 1 million codes is enough to cover all of this. So the obvious conclusion is that the QR codes are recycled.

There's no change to our schema, but now our diagram includes a recyclable pool of available QR Codes:

![Schema v2](/McDonalds/Schema-v2.jpeg)

## Regional Partitioning

When you first sign-up to the loyalty app, you are asked to select a country / region. I expect the QR Codes in one region can be repeated in another. So let's partition our pool per region and the `region` to our schema:

![Schema v3](/McDonalds/Schema-v3.jpeg)

and now the RPC request looks like:

```
GET /loyalty_session?qr_code=M204941&region=AE
```

** _I wouldn't be surprised if it was more fine-grained than that, perhaps at a city or district level_.

## Rate Limit + Geofencing?

When redeeming an offer, a customer has 15 minutes to scan the QR code. So I suppose a session has an expiry of 15 minutes. After 15 minutes, the session is invalidated and the QR code is pushed back to the available pool.

Let's add this to our schema:

![Schema v4](/McDonalds/Schema-v4.jpeg)

With this information, we can actually calculate what's the maximum number of loyalty transactions (earn / redeem) McDonalds can process per second. If the pool size is 1,000,000 QR Codes and a session lasts 15 minutes, McDonalds can handle:

```text/plain
1,000,000 / 15 = 66,666.67 = codes per minute = roughly 1000 loyalty transactions per second for a given region.
```

1000 loyalty transactions per second is hardly enough for large regions such as the US, Canada and so on. This further convinces me that the region property is far more fine-grained. I expect it might even be linked to the nearest store at the time that the session is created. 

Interestingly enough, the App is able to generate a QR code even when location permissions aren't granted to it. I expect it might still go ahead with an approximate location from the IP Address. I might toy around this with this aspect a bit more in the future.

In any case, let's rename the `region` column with `zone_id` to accomodate this:

![Schema v5](/McDonalds/Schema-v5.jpeg)

This rate-limit would no doubt need to be enforced on the backend. I expect that the API that creates the session and generates the QR code would allow 3 QR Codes per user per 15 minute (one for earn, two for redemption). In practice, their rate limit seems to be far more generous than that. 

## Session State

I mostly use the McDonalds app to redeem a free ice-cream and that hardly takes me a minute or two at the kiosk. The system would want to put the QR Code back in the pool as soon as possible rather than wait for the full 15 minutes. 

So once the payment is processed and the transaction is completed from the kiosk, I expect the kiosk to make an RPC call to close the session. The backend then pushes the QR code back to the pool of available codes.

Let's add `session_status`, `session_closed_at` and `order_id` to our schema:
- `order_id`: If the loyalty session translated to an order, we store the corresponding `order_id`.
- `session_status`: To keep track of whether the session `EXPIRED` or led to a conversion
- `session_closed_at`: What time did the session actually close.

![Schema v6](/McDonalds/Schema-v6.jpeg)

## Why not just use a UUID?

This is the part that I really like because I appreciate the attention to detail. McDonalds could have certainly gone for a UUID but then, if for some reason their QR scanner didn't work or couldn't scan correctly, rather than have your **loyal** customers type out 36 characters, they just need to punch in 6 numbers. 

Not only is it better customer experience, it also keeps the line at the kiosk moving quickly.

## Next Steps

As I mentioned earlier, I'd like to decompile the McDonalds apk to see what I can find. I expect the source code to be obfoscated but that's why in this article, I tried to imagine what their API might look like. With any luck and if i'm in the ball park, I expect to find endpoints with similar names and parameters. 