---
title: "Idempotency Keys"
date: 2023-10-05T15:19:00+03:00
draft: false
summary: "What are idempotency keys and how to use them"
---

For the last 2 years, I've been working on the backend of a digital bank. One of the important concepts that I learned was about **Idempotency Keys**. In this article, I will talk about:

- What is Idempotency?
- Why is idempotency important for banking?
- What are idempotency keys?
- How are idempotency keys implemented?

# What is idempotency?

An idempotent action is one that if you were to perform it multiple times, you would get the same output as if you had performed it once.

In terms of  REST APIs, An idempotent endpoint is one which does not change the state of the resource when you call the endpoint.

`GET` endpoints are meant to be idempotent. If you call, say `GET /profile` multiple times, it won't cause any changes to happen in the profile resource.

`POST` endpoints, by contrast, are **NOT** idempotent. So if we had a `POST /profile` endpoint; you'd expect that every time this endpoint was called, a new `profile` resource is created on the backend.

## Why is idempotency important for banking?

Now let's say you're building the backend for a bank and you build an endpoint (we'll call it `POST /transfer`) that does a transfer i.e. it deducts money from your account and credits it to your friends account.

- So let's say you had $100 in your bank account, and you used this endpoint to transfer $10.

- If this endpoint was called once, you'd have $90 and your friend would have $10.

Now imagine this: A mobile client calls this endpoint and the connection breaks or times out. 

At this point, you don't you know if the transaction was successful. 

The simplest solution (albeit not the only solution) would be to retry the endpoint but if the transaction was successful, then the transfer amount will be deducted from the customer's account **TWICE**. This will stress out the customer and negatively impact the banks reputation.

What we need is a way to let the backend now that we're retrying the transaction, rather than intentionally performing a new one. This is where idempotency keys come in handy.

## What are idempotency keys?

An idempotency key is a unique set of characters (typically just a UUID) that is generated by the client (e.g. the mobile app) and sent with the API request in the header.

```
POST /transfer
Host: example.com
Content-Type: application/json
Content-Length: 42
X-Idempotency-Key: 8FB4A212-5B24-4BF3-AF90-C956C5FF006C

{
	"Amount": "10.00",
	"Currency": "USD"
}
```

The backend checks if it has successfully processed a transaction with the same idempotency key before. If it has, it could either return an error or return the previously created resource.


Idempotency Keys can expire. For example, the [Mambu Core Banking System](https://api.mambu.com/#idempotency) expires the idempotency key after 6 hours. This means that let's say the time is 12:00 PM and we call the `POST /transfer` endpoint a number of times.


| Number of times `POST /transfer` called | Time    | Idempotency Key | Result                                                                   |
|-----------------------------------------|---------|-----------------|--------------------------------------------------------------------------|
| 1                                       | 12:00PM | `0000`          | A transfer is created. Customers account is debited.                     |
| 2                                       | 1:00PM  | `0000`          | Idempotency key reused and hasn't expired. New transfer is not created.  |
| 3                                       | 5:59PM  | `0000`          | Idempotency key reused and hasn't expired. New transfer is not created.  |
| 4                                       | 6:00PM  | `0000`          | Idempotency key reused and **has** expired. New transfer **is created.** |


## How are idempotency keys implemented?

### Front-end

- The front-end (e.g. mobile app) will typically have a user journey for creating a transfer.
- At the initial step of this user journey, the front-end will generate an idempotency key. 
- When the `POST /transfer` endpoint is called (near the end of the journey), the idempotency key will be sent in the header.
- In case the request times-out or the connection breaks, the front-end may display an error screen with a retry button.
- The retry button will call the same `POST /transfer` with the same idempotency key.

### Backend

- If the backend is able to process the transaction successfully, it will store the idempotency key and the response in a cache as a key-value pair (the key being the idempotency key and the response being the value).The key-value pair will be stored with a TTL e.g. 6 hours.

- If the endpoint is called a second time, the endpoint will first confer with the cache to ensure the request hasn't already been processed.

- If it has, the cached response will be resent to the client.